"""Module with test function from CEC2020 RWSOC benchmark
"""
import numpy as np

from test_functions.test_function import TestFunction
from utils.cec20_parameters import get_dim_and_constraints_cec20_constrained, get_cec2020_constrained_optimum

def cec20_func(x, prob_k):
    (ps, D) = x.shape

    if prob_k == 1:
        # Heat Exchanger Network Design (case 1)
        f = 35 * x[:, 0]**0.6 + 35 * x[:, 1]**0.6
        g = np.zeros(ps)
        h = np.zeros((ps, 8))
        h[:, 0] = 200 * x[:, 0] * x[:, 3] - x[:, 2]
        h[:, 1] = 200 * x[:, 1] * x[:, 5] - x[:, 4]
        h[:, 2] = x[:, 2] - 10000 * (x[:, 6] - 100)
        h[:, 3] = x[:, 4] - 10000 * (300 - x[:, 6])
        h[:, 4] = x[:, 2] - 10000 * (600 - x[:, 7])
        h[:, 5] = x[:, 4] - 10000 * (900 - x[:, 8])
        h[:, 6] = x[:, 3] * np.log(np.abs(x[:, 7] - 100) + 1e-8) - x[:, 3] * np.log(600 - x[:, 6] + 1e-8) - x[:, 7] + x[:, 6] + 500
        h[:, 7] = x[:, 5] * np.log(np.abs(x[:, 8] - x[:, 6]) + 1e-8) - x[:, 5] * np.log(600) - x[:, 8] + x[:, 6] + 600

    if prob_k == 2:
        # Heat Exchanger Network Design (case 2)
        f = (x[:, 0] / (120 * x[:, 3]))**0.6 + (x[:, 1] / (80 * x[:, 4]))**0.6 + (x[:, 2] / (40 * x[:, 5]))**0.6
        g = np.zeros(ps)
        h = np.zeros((ps, 9))
        h[:, 0] = x[:, 0] - 1e4 * (x[:, 6] - 100)
        h[:, 1] = x[:, 1] - 1e4 * (x[:, 7] - x[:, 6])
        h[:, 2] = x[:, 2] - 1e4 * (500 - x[:, 7])
        h[:, 3] = x[:, 0] - 1e4 * (300 - x[:, 8])
        h[:, 4] = x[:, 1] - 1e4 * (400 - x[:, 9])
        h[:, 5] = x[:, 2] - 1e4 * (600 - x[:, 10])
        h[:, 6] = x[:, 3] * np.log(np.abs(x[:, 8] - 100) + 1e-8) - x[:, 3] * np.log(300 - x[:, 6] + 1e-8) - x[:, 8] - x[:, 6] + 400
        h[:, 7] = x[:, 4] * np.log(np.abs(x[:, 9] - x[:, 6]) + 1e-8) - x[:, 4] * np.log(np.abs(400 - x[:, 7]) + 1e-8) - x[:, 9] + x[:, 6] - x[:, 7] + 400
        h[:, 8] = x[:, 5] * np.log(np.abs(x[:, 10] - x[:, 7]) + 1e-8) - x[:, 5] * np.log(100) - x[:, 10] + x[:, 7] + 100

    if prob_k == 3:
        # Optimal Operation of Alkylation Unit
        f = -1.715 * x[:, 0] - 0.035 * x[:, 0] * x[:, 5] - 4.0565 * x[:, 2] - 10.0 * x[:, 1] + 0.063 * x[:, 2] * x[:, 4]
        h = np.zeros(ps)
        g = np.zeros((ps, 14))
        g[:, 0] = 0.0059553571 * x[:, 5]**2 * x[:, 0] + 0.88392857 * x[:, 2] - 0.1175625 * x[:, 5] * x[:, 0] - x[:, 0]
        g[:, 1] = 1.1088 * x[:, 0] + 0.1303533 * x[:, 0] * x[:, 5] - 0.0066033 * x[:, 0] * x[:, 5]**2 - x[:, 2]
        g[:, 2] = 6.66173269 * x[:, 5]**2 + 172.39878 * x[:, 4] - 56.596669 * x[:, 3] - 191.20592 * x[:, 5] - 10000
        g[:, 3] = 1.08702 * x[:, 5] + 0.32175 * x[:, 3] - 0.03762 * x[:, 5]**2 - x[:, 4] + 56.85075
        g[:, 4] = 0.006198 * x[:, 6] * x[:, 3] * x[:, 2] + 2462.3121 * x[:, 1] - 25.125634 * x[:, 1] * x[:, 3] - x[:, 2] * x[:, 3]
        g[:, 5] = 161.18996 * x[:, 2] * x[:, 3] + 5000.0 * x[:, 1] * x[:, 3] - 489510.0 * x[:, 1] - x[:, 2] * x[:, 3] * x[:, 6]
        g[:, 6] = 0.33 * x[:, 6] - x[:, 4] + 44.333333
        g[:, 7] = 0.022556 * x[:, 4] - 0.007595 * x[:, 6] - 1.0
        g[:, 8] = 0.00061 * x[:, 2] - 0.0005 * x[:, 0] - 1.0
        g[:, 9] = 0.819672 * x[:, 0] - x[:, 2] + 0.819672
        g[:, 10] = 24500.0 * x[:, 1] - 250.0 * x[:, 1] * x[:, 3] - x[:, 2] * x[:, 3]
        g[:, 11] = 1020.4082 * x[:, 3] * x[:, 1] + 1.2244898 * x[:, 2] * x[:, 3] - 100000.0 * x[:, 1]
        g[:, 12] = 6.25 * x[:, 0] * x[:, 5] + 6.25 * x[:, 0] - 7.625 * x[:, 2] - 100000.0
        g[:, 13] = 1.22 * x[:, 2] - x[:, 5] * x[:, 0] - x[:, 0] + 1.0

    if prob_k == 4:
        # Reactor Network Design (RND)
        k1 = 0.09755988
        k2 = 0.99 * k1
        k3 = 0.0391908
        k4 = 0.9 * k3
        f = -x[:, 3]
        h = np.zeros((ps, 4))
        g = np.zeros((ps, 1))
        h[:, 0] = x[:, 0] + k1 * x[:, 1] * x[:, 4] - 1
        h[:, 1] = x[:, 1] - x[:, 0] + k2 * x[:, 1] * x[:, 5]
        h[:, 2] = x[:, 2] + x[:, 0] + k3 * x[:, 2] * x[:, 4] - 1
        h[:, 3] = x[:, 3] - x[:, 2] + x[:, 1] - x[:, 0] + k4 * x[:, 3] * x[:, 5]
        g[:, 0] = np.sqrt(x[:, 4]) + np.sqrt(x[:, 5]) - 4

    if prob_k == 5:
        # Haverly's Pooling Problem
        f = -(9 * x[:, 0] + 15 * x[:, 1] - 6 * x[:, 2] - 16 * x[:, 3] - 10 * (x[:, 4] + x[:, 5]))
        g = np.zeros((ps, 2))
        h = np.zeros((ps, 4))
        g[:, 0] = x[:, 8] * x[:, 6] + 2 * x[:, 4] - 2.5 * x[:, 0]
        g[:, 1] = x[:, 8] * x[:, 7] + 2 * x[:, 5] - 1.5 * x[:, 1]
        h[:, 0] = x[:, 6] + x[:, 7] - x[:, 2] - x[:, 3]
        h[:, 1] = x[:, 0] - x[:, 6] - x[:, 4]
        h[:, 2] = x[:, 1] - x[:, 7] - x[:, 5]
        h[:, 3] = x[:, 8] * x[:, 6] + x[:, 8] * x[:, 7] - 3 * x[:, 2] - x[:, 3]

    if prob_k == 6:
        # Blending-Pooling-Separation problem
        f = 0.9979 + 0.00432 * x[:, 4] + 0.01517 * x[:, 12]
        g = np.zeros((ps, 1))
        h = np.zeros((ps, 32))
        h[:, 0] = x[:, 0] + x[:, 1] + x[:, 2] + x[:, 3] - 300
        h[:, 1] = x[:, 5] - x[:, 6] - x[:, 7]
        h[:, 2] = x[:, 8] - x[:, 9] - x[:, 10] - x[:, 11]
        h[:, 3] = x[:, 13] - x[:, 14] - x[:, 15] - x[:, 16]
        h[:, 4] = x[:, 17] - x[:, 18] - x[:, 19]
        h[:, 5] = x[:, 4] * x[:, 20] - x[:, 5] * x[:, 21] - x[:, 8] * x[:, 22]
        h[:, 6] = x[:, 4] * x[:, 23] - x[:, 5] * x[:, 24] - x[:, 8] * x[:, 25]
        h[:, 7] = x[:, 4] * x[:, 26] - x[:, 5] * x[:, 27] - x[:, 8] * x[:, 28]
        h[:, 8] = x[:, 12] * x[:, 29] - x[:, 13] * x[:, 30] - x[:, 17] * x[:, 31]
        h[:, 9] = x[:, 12] * x[:, 32] - x[:, 13] * x[:, 33] - x[:, 17] * x[:, 34]
        h[:, 10] = x[:, 12] * x[:, 35] - x[:, 13] * x[:, 36] - x[:, 17] * x[:, 37]

        h[:, 11] = 1/3 * x[:, 0] + x[:, 14] * x[:, 30] - x[:, 4] * x[:, 20]
        h[:, 12] = 1/3 * x[:, 0] + x[:, 14] * x[:, 33] - x[:, 4] * x[:, 23]
        h[:, 13] = 1/3 * x[:, 0] + x[:, 14] * x[:, 36] - x[:, 4] * x[:, 26]
        h[:, 14] = 1/3 * x[:, 1] + x[:, 9] * x[:, 22] - x[:, 12] * x[:, 29]
        h[:, 15] = 1/3 * x[:, 1] + x[:, 9] * x[:, 25] - x[:, 12] * x[:, 32]
        h[:, 16] = 1/3 * x[:, 1] + x[:, 9] * x[:, 28] - x[:, 12] * x[:, 35]

        h[:, 17] = 1/3 * x[:, 2] + x[:, 6] * x[:, 21] + x[:, 10] * x[:, 22] + x[:, 15] * x[:, 30] + x[:, 18] * x[:, 31] - 30
        h[:, 18] = 1/3 * x[:, 2] + x[:, 6] * x[:, 24] + x[:, 10] * x[:, 25] + x[:, 15] * x[:, 33] + x[:, 18] * x[:, 34] - 50
        h[:, 19] = 1/3 * x[:, 2] + x[:, 6] * x[:, 27] + x[:, 10] * x[:, 28] + x[:, 15] * x[:, 36] + x[:, 18] * x[:, 37] - 30

        h[:, 20] = x[:, 20] + x[:, 23] + x[:, 26] - 1
        h[:, 21] = x[:, 21] + x[:, 24] + x[:, 27] - 1
        h[:, 22] = x[:, 22] + x[:, 25] + x[:, 28] - 1
        h[:, 23] = x[:, 29] + x[:, 32] + x[:, 35] - 1
        h[:, 24] = x[:, 30] + x[:, 33] + x[:, 36] - 1
        h[:, 25] = x[:, 31] + x[:, 34] + x[:, 37] - 1
        h[:, 26] = x[:, 24]
        h[:, 27] = x[:, 27]
        h[:, 28] = x[:, 22]
        h[:, 29] = x[:, 36]
        h[:, 30] = x[:, 31]
        h[:, 31] = x[:, 34]

    if prob_k == 7:
        # Propane, Isobutane, n-Butane Nonsharp Separation
        c = np.array([[0.23947, 0.75835],
                    [-0.0139904, -0.0661588],
                    [0.0093514, 0.0338147],
                    [0.0077308, 0.0373349],
                    [-0.0005719, 0.0016371],
                    [0.0042656, 0.0288996]])
        f = c[0, 0] + (c[1, 0] + c[2, 0] * x[:, 23] + c[3, 0] * x[:, 27] + c[4, 0] * x[:, 32] + c[5, 0] * x[:, 33]) * x[:, 4] + \
            c[0, 1] + (c[1, 1] + c[2, 1] * x[:, 25] + c[3, 1] * x[:, 30] + c[4, 1] * x[:, 37] + c[5, 1] * x[:, 38]) * x[:, 12]
        g = np.zeros((ps, 1))
        h = np.zeros((ps, 38))

        h[:, 0] = x[:, 0] + x[:, 1] + x[:, 2] + x[:, 3] - 300
        h[:, 1] = x[:, 5] - x[:, 6] - x[:, 7]
        h[:, 2] = x[:, 8] - x[:, 9] - x[:, 10] - x[:, 11]
        h[:, 3] = x[:, 13] - x[:, 14] - x[:, 15] - x[:, 16]
        h[:, 4] = x[:, 17] - x[:, 18] - x[:, 19]
        h[:, 5] = x[:, 5] * x[:, 20] - x[:, 23] * x[:, 24]
        h[:, 6] = x[:, 13] * x[:, 21] - x[:, 25] * x[:, 26]
        h[:, 7] = x[:, 8] * x[:, 22] - x[:, 27] * x[:, 28]
        h[:, 8] = x[:, 17] * x[:, 29] - x[:, 30] * x[:, 31]
        h[:, 9] = x[:, 24] - x[:, 4] * x[:, 32]
        h[:, 10] = x[:, 28] - x[:, 4] * x[:, 33]

        h[:, 11] = x[:, 34] - x[:, 4] * x[:, 35]
        h[:, 12] = x[:, 36] - x[:, 12] * x[:, 37]
        h[:, 13] = x[:, 26] - x[:, 12] * x[:, 38]
        h[:, 14] = x[:, 31] - x[:, 12] * x[:, 39]
        h[:, 15] = x[:, 24] - x[:, 5] * x[:, 20] - x[:, 8] * x[:, 40]
        h[:, 16] = x[:, 28] - x[:, 5] * x[:, 41] - x[:, 8] * x[:, 22]
        h[:, 17] = x[:, 34] - x[:, 5] * x[:, 42] - x[:, 8] * x[:, 43]
        h[:, 18] = x[:, 36] - x[:, 13] * x[:, 44] - x[:, 17] * x[:, 45]
        h[:, 19] = x[:, 26] - x[:, 13] * x[:, 21] - x[:, 17] * x[:, 46]
        h[:, 20] = x[:, 31] - x[:, 13] * x[:, 47] - x[:, 17] * x[:, 29]
        h[:, 21] = (1/3) * x[:, 0] + x[:, 14] * x[:, 44] - x[:, 24]
        h[:, 22] = (1/3) * x[:, 0] + x[:, 14] * x[:, 21] - x[:, 28]
        h[:, 23] = (1/3) * x[:, 0] + x[:, 14] * x[:, 47] - x[:, 34]
        h[:, 24] = (1/3) * x[:, 1] + x[:, 9] * x[:, 40] - x[:, 36]
        h[:, 25] = (1/3) * x[:, 1] + x[:, 9] * x[:, 22] - x[:, 26]
        h[:, 26] = (1/3) * x[:, 1] + x[:, 9] * x[:, 43] - x[:, 31]
        h[:, 27] = x[:, 32] + x[:, 33] + x[:, 35] - 1
        h[:, 28] = x[:, 20] + x[:, 41] + x[:, 42] - 1
        h[:, 29] = x[:, 40] + x[:, 22] + x[:, 43] - 1
        h[:, 30] = x[:, 37] + x[:, 38] + x[:, 39] - 1
        h[:, 31] = x[:, 44] + x[:, 21] + x[:, 47] - 1
        h[:, 32] = x[:, 45] + x[:, 46] + x[:, 29] - 1
        h[:, 33] = x[:, 42]
        h[:, 34] = x[:, 45]
        h[:, 35] = (1 / 3) * x[:, 2] + x[:, 6] * x[:, 20] + x[:, 10] * x[:, 40] + x[:, 15] * x[:, 44] + x[:, 18] * x[:, 45] - 30
        h[:, 36] = (1 / 3) * x[:, 2] + x[:, 6] * x[:, 41] + x[:, 10] * x[:, 22] + x[:, 15] * x[:, 21] + x[:, 18] * x[:, 46] - 50
        h[:, 37] = (1 / 3) * x[:, 2] + x[:, 6] * x[:, 42] + x[:, 10] * x[:, 43] + x[:, 15] * x[:, 47] + x[:, 18] * x[:, 29] - 30

    if prob_k == 8:
        # Process synthesis problem
        x1 = np.round(x[:, 1])
        f = 2 * x[:, 0] + x1
        g = np.zeros((ps, 2))
        h = np.zeros((ps, 1))
        g[:, 0] = 1.25 - x[:, 0] ** 2 - x1
        g[:, 1] = x[:, 0] + x1 - 1.6

    if prob_k == 9:
        # Process synthesis and design problem
        x2 = np.round(x[:, 2])
        f = -x2 + 2 * x[:, 0] + x[:, 1]
        g = np.zeros((ps, 1))
        h = np.zeros((ps, 1))
        h[:, 0] = x[:, 0] - 2 * np.exp(-x[:, 1])
        g[:, 0] = -x[:, 0] + x[:, 1] + x2

    if prob_k == 10:
        # Process flow sheeting problem
        x2 = np.round(x[:, 2])
        f = -0.7 * x2 + 5 * (x[:, 0] - 0.5) ** 2 + 0.8
        g = np.zeros((ps, 3))
        h = np.zeros((ps, 1))
        g[:, 0] = -np.exp(x[:, 0] - 0.2) - x[:, 1]
        g[:, 1] = x[:, 1] + 1.1 * x2 + 1
        g[:, 2] = x[:, 0] - x2 - 0.2

    if prob_k == 11:
        # Two-reactor Problem
        x1 = x[:, 0]
        x2 = x[:, 1]
        v1 = x[:, 2]
        v2 = x[:, 3]
        y1 = np.round(x[:, 4])
        y2 = np.round(x[:, 5])
        x_ = x[:, 6]
        
        z1 = 0.9 * (1 - np.exp(-0.5 * v1)) * x1
        z2 = 0.8 * (1 - np.exp(-0.4 * v2)) * x2
        
        f = 7.5 * y1 + 5.5 * y2 + 7 * v1 + 6 * v2 + 5 * x_
        h = np.zeros((ps, 4))
        g = np.zeros((ps, 4))
        
        h[:, 0] = y1 + y2 - 1
        h[:, 1] = z1 + z2 - 10
        h[:, 2] = x1 + x2 - x_
        h[:, 3] = z1 * y1 + z2 * y2 - 10
        g[:, 0] = v1 - 10 * y1
        g[:, 1] = v2 - 10 * y2
        g[:, 2] = x1 - 20 * y1
        g[:, 3] = x2 - 20 * y2

    if prob_k == 12:
        # Process synthesis problem
        x1 = x[:, 0]
        x2 = x[:, 1]
        x3 = x[:, 2]
        y1 = np.round(x[:, 3])
        y2 = np.round(x[:, 4])
        y3 = np.round(x[:, 5])
        y4 = np.round(x[:, 6])
        f = (y1 - 1) ** 2 + (y2 - 1) ** 2 + (y3 - 1) ** 2 - np.log(y4 + 1) + (x1 - 1) ** 22 + (x2 - 2) ** 2 + (x3 - 3) ** 2
        h = np.zeros(ps)
        g = np.zeros((ps, 9))
        g[:, 0] = x1 + x2 + x3 + y1 + y2 + y3 - 5
        g[:, 1] = y3 ** 2 + x1 ** 2 + x2 ** 2 + x3 ** 2 - 5.5
        g[:, 2] = x1 + y1 - 1.2
        g[:, 3] = x2 + y2 - 1.8
        g[:, 4] = x3 + y3 - 2.5
        g[:, 5] = x1 + y4 - 1.2
        g[:, 6] = y2 ** 2 + x2 ** 2 - 1.64
        g[:, 7] = y3 ** 2 + x3 ** 2 - 4.25
        g[:, 8] = y2 ** 2 + x3 ** 2 - 4.64

    if prob_k == 13:
        # Process design Problem
        x1 = x[:, 0]
        x2 = x[:, 1]
        x3 = x[:, 2]
        y1 = np.round(x[:, 3])
        y2 = np.round(x[:, 4])
        f = -5.357854 * x1 ** 2 - 0.835689 * y1 * x3 - 37.29329 * y1 + 40792.141
        g = np.zeros((ps, 3))
        h = np.zeros(ps)
        a = [85.334407, 0.0056858, 0.0006262, 0.0022053, 80.51249, 0.0071317,
            0.0029955, 0.0021813, 9.300961, 0.0047026, 0.0012547, 0.0019085]
        g[:, 0] = a[0] + a[1] * y2 * x3 + a[2] * y1 * x2 - a[3] * y1 * y1 * x3 - 92
        g[:, 1] = a[4] + a[5] * y2 * x3 + a[6] * y1 * x2 + a[7] * x1 ** 2 - 90 - 20
        g[:, 2] = a[8] + a[9] * y1 * x2 + a[10] * y1 * x1 + a[11] * x1 * x2 - 20 - 5

    if prob_k == 14:
        # Multi-product batch plant
        # constant
        S = np.array([[2, 3, 4], [4, 6, 3]])
        t = np.array([[8, 20, 8], [16, 4, 4]])
        H = 6000
        alp = 250
        beta = 0.6
        Q1 = 40000
        Q2 = 20000
        
        # decision Variable
        N1 = np.round(x[:, 0])
        N2 = np.round(x[:, 1])
        N3 = np.round(x[:, 2])
        V1 = x[:, 3]
        V2 = x[:, 4]
        V3 = x[:, 5]
        TL1 = x[:, 6]
        TL2 = x[:, 7]
        B1 = x[:, 8]
        B2 = x[:, 9]
        
        # objective function
        f = alp * (N1 * V1 ** beta + N2 * V2 ** beta + N3 * V3 ** beta)
        g = np.zeros((ps, 10))
        h = np.zeros(ps)
        
        # constraints
        g[:, 0] = Q1 * TL1 / B1 + Q2 * TL2 / B2 - H
        g[:, 1] = S[0, 0] * B1 + S[1, 0] * B2 - V1
        g[:, 2] = S[0, 1] * B1 + S[1, 1] * B2 - V2
        g[:, 3] = S[0, 2] * B1 + S[1, 2] * B2 - V3
        g[:, 4] = t[0, 0] - N1 * TL1
        g[:, 5] = t[0, 1] - N2 * TL1
        g[:, 6] = t[0, 2] - N3 * TL1
        g[:, 7] = t[1, 0] - N1 * TL2
        g[:, 8] = t[1, 1] - N2 * TL2
        g[:, 9] = t[1, 2] - N3 * TL2

    if prob_k == 15:
        # Weight Minimization of a Speed Reducer
        f = 0.7854 * x[:, 0] * x[:, 1] ** 2 * (3.3333 * x[:, 2] ** 2 + 14.9334 * x[:, 2] - 43.0934) - \
            1.508 * x[:, 0] * (x[:, 5] ** 2 + x[:, 6] ** 2) + \
            7.477 * (x[:, 5] ** 3 + x[:, 6] ** 3) + \
            0.7854 * (x[:, 3] * x[:, 5] ** 2 + x[:, 4] * x[:, 6] ** 2)
        g = np.zeros((ps, 11))
        h = np.zeros(ps)
        g[:, 0] = -x[:, 0] * x[:, 1] ** 2 * x[:, 2] + 27
        g[:, 1] = -x[:, 0] * x[:, 1] ** 2 * x[:, 2] ** 2 + 397.5
        g[:, 2] = -x[:, 1] * x[:, 5] ** 4 * x[:, 2] * x[:, 3] ** (-3) + 1.93
        g[:, 3] = -x[:, 1] * x[:, 6] ** 4 * x[:, 2] / x[:, 4] ** 3 + 1.93
        g[:, 4] = 10 * x[:, 5] ** (-3) * np.sqrt(16.91 * 10 ** 6 + (745 * x[:, 3] / (x[:, 1] * x[:, 2])) ** 2) - 1100
        g[:, 5] = 10 * x[:, 6] ** (-3) * np.sqrt(157.5 * 10 ** 6 + (745 * x[:, 4] / (x[:, 1] * x[:, 2])) ** 2) - 850
        g[:, 6] = x[:, 1] * x[:, 2] - 40
        g[:, 7] = -x[:, 0] / x[:, 1] + 5
        g[:, 8] = x[:, 0] / x[:, 1] - 12
        g[:, 9] = 1.5 * x[:, 5] - x[:, 3] + 1.9
        g[:, 10] = 1.1 * x[:, 6] - x[:, 4] + 1.9
    
    if prob_k == 16:
        # Optimal Design of Industrial refrigeration System
        f = 63098.88 * x[:, 1] * x[:, 3] * x[:, 11] + 5441.5 * x[:, 1] ** 2 * x[:, 11] + \
            115055.5 * x[:, 1] ** 1.664 * x[:, 5] + 6172.27 * x[:, 1] ** 2 * x[:, 5] + \
            63098.88 * x[:, 0] * x[:, 2] * x[:, 10] + 5441.5 * x[:, 0] ** 2 * x[:, 10] + \
            115055.5 * x[:, 0] ** 1.664 * x[:, 4] + 6172.27 * x[:, 0] ** 2 * x[:, 4] + \
            140.53 * x[:, 0] * x[:, 10] + 281.29 * x[:, 2] * x[:, 10] + \
            70.26 * x[:, 0] ** 2 + 281.29 * x[:, 0] * x[:, 2] + 281.29 * x[:, 2] ** 2 + \
            14437 * x[:, 7] ** 1.8812 * x[:, 11] ** 0.3424 * x[:, 9] * x[:, 13] ** (-1) * \
            x[:, 0] ** 2 * x[:, 6] * x[:, 8] ** (-1) + \
            20470.2 * x[:, 6] ** (2.893) * x[:, 10] ** 0.316 * x[:, 0] ** 2
        
        g = np.zeros((ps, 15))
        h = np.zeros(ps)

        g[:, 0] = 1.524 * x[:, 6] ** (-1) - 1
        g[:, 1] = 1.524 * x[:, 7] ** (-1) - 1
        g[:, 2] = 0.07789 * x[:, 0] - 2 * x[:, 6] ** (-1) * x[:, 8] - 1
        g[:, 3] = 7.05305 * x[:, 8] ** (-1) * x[:, 0] ** 2 * x[:, 9] * x[:, 7] ** (-1) * x[:, 1] ** (-1) * x[:, 13] ** (-1) - 1
        g[:, 4] = 0.0833 / x[:, 12] * x[:, 13] - 1
        g[:, 5] = 0.04771 * x[:, 9] * x[:, 7] ** 1.8812 * x[:, 11] ** 0.3424 - 1
        g[:, 6] = 0.0488 * x[:, 8] * x[:, 6] ** 1.893 * x[:, 10] ** 0.316 - 1
        g[:, 7] = 0.0099 * x[:, 0] / x[:, 2] - 1
        g[:, 8] = 0.0193 * x[:, 1] / x[:, 3] - 1
        g[:, 9] = 0.0298 * x[:, 0] / x[:, 4] - 1
        g[:, 10] = 47.136 * x[:, 1] ** 0.333 / x[:, 9] * x[:, 11] - 1.333 * x[:, 7] * x[:, 12] ** 2.1195 + \
                62.08 * x[:, 12] ** 2.1195 * x[:, 7] ** 0.2 / (x[:, 11] * x[:, 9]) - 1
        g[:, 11] = 0.056 * x[:, 1] / x[:, 5] - 1
        g[:, 12] = 2 / x[:, 8] - 1
        g[:, 13] = 2 / x[:, 9] - 1
        g[:, 14] = x[:, 11] / x[:, 10] - 1

    if prob_k == 17:
        # Tension/compression spring design (case 1)
        f = x[:, 0] ** 2 * x[:, 1] * (x[:, 2] + 2)
        h = np.zeros(ps)
        g = np.zeros((ps, 4))
        g[:, 0] = 1 - (x[:, 1] ** 3 * x[:, 2]) / (71785 * x[:, 0] ** 4)
        g[:, 1] = (4 * x[:, 1] ** 2 - x[:, 0] * x[:, 1]) / (12566 * (x[:, 1] * x[:, 0] ** 3 - x[:, 0] ** 4)) + \
                1 / (5108 * x[:, 0] ** 2) - 1
        g[:, 2] = 1 - 140.45 * x[:, 0] / (x[:, 1] ** 2 * x[:, 2])
        g[:, 3] = (x[:, 0] + x[:, 1]) / 1.5 - 1

    if prob_k == 18:
        # update
        x0 = 0.0625 * np.round(x[:, 0])
        x1 = 0.0625 * np.round(x[:, 1])
        # Pressure vessel design
        f = 0.6224 * x0 * x[:, 2] * x[:, 3] + 1.7781 * x1 * x[:, 2] ** 2 + 3.1661 * x0 ** 2 * x[:, 3] + \
            19.84 * x0 ** 2 * x[:, 2]
        g = np.zeros((ps, 4))
        h = np.zeros(ps)
        g[:, 0] = -x0 + 0.0193 * x[:, 2]
        g[:, 1] = -x1 + 0.00954 * x[:, 2]
        g[:, 2] = -np.pi * x[:, 2] ** 2 * x[:, 3] - 4 / 3 * np.pi * x[:, 2] ** 3 + 1296000
        g[:, 3] = x[:, 3] - 240

    if prob_k == 19:
        # Welded beam design
        f = 1.10471 * x[:, 0] ** 2 * x[:, 1] + 0.04811 * x[:, 2] * x[:, 3] * (14 + x[:, 1])
        h = np.zeros(ps)
        g = np.zeros((ps, 5))
        P = 6000
        L = 14
        delta_max = 0.25
        E = 30 * 1e6
        G = 12 * 1e6
        T_max = 13600
        sigma_max = 30000
        Pc = 4.013 * E * np.sqrt(x[:, 2] ** 2 * x[:, 3] ** 6 / 30) / L ** 2 * (
                    1 - x[:, 2] / (2 * L) * np.sqrt(E / (4 * G)))
        sigma = 6 * P * L / (x[:, 3] * x[:, 2] ** 2)
        delta = 6 * P * L ** 3 / (E * x[:, 2] ** 2 * x[:, 3])
        J = 2 * (np.sqrt(2) * x[:, 0] * x[:, 1] * (x[:, 1] ** 2 / 4 + (x[:, 0] + x[:, 2]) ** 2 / 4))
        R = np.sqrt(x[:, 1] ** 2 / 4 + (x[:, 0] + x[:, 2]) ** 2 / 4)
        M = P * (L + x[:, 1] / 2)
        ttt = M * R / J
        tt = P / (np.sqrt(2) * x[:, 0] * x[:, 1])
        t = np.sqrt(tt ** 2 + 2 * tt * ttt * x[:, 1] / (2 * R) + ttt ** 2)
        # constraints
        g[:, 0] = t - T_max
        g[:, 1] = sigma - sigma_max
        g[:, 2] = x[:, 0] - x[:, 3]
        g[:, 3] = delta - delta_max
        g[:, 4] = P - Pc
        
    if prob_k == 20:
        # Three-bar truss design problem
        f = (2 * np.sqrt(2) * x[:, 0] + x[:, 1]) * 100
        g = np.zeros((ps, 3))
        h = np.zeros(ps)
        g[:, 0] = (np.sqrt(2) * x[:, 0] + x[:, 1]) / (np.sqrt(2) * x[:, 0] ** 2 + 2 * x[:, 0] * x[:, 1]) * 2 - 2
        g[:, 1] = x[:, 1] / (np.sqrt(2) * x[:, 0] ** 2 + 2 * x[:, 0] * x[:, 1]) * 2 - 2
        g[:, 2] = 1 / (np.sqrt(2) * x[:, 1] + x[:, 0]) * 2 - 2

    if len(g.shape) == 1:
        g = g.reshape((g.shape[0], 1))
    if len(h.shape) == 1:
        h = h.reshape((h.shape[0], 1))
    if ps == 1:
        f = f[0]

    return f, g, h

def cec20_func_factory():
    funcs = []
    optimum = get_cec2020_constrained_optimum()
    for i in range(20):
        opt = optimum[i]
        D, gn, hn = get_dim_and_constraints_cec20_constrained(i+1)
        fun = TestFunction(f"RC{i+1}", lambda x, idx=i: cec20_func(x, idx+1), D, opt, gn, hn)
        funcs.append(fun)
    return funcs

CEC2020_CONSTRAINED = cec20_func_factory()
